T1 = go(p(20,20)), T2 = go(p(1,1)), T3 = go(p(4,10)), solve_task(T1, _, _), solve_task(T2, _, _), solve_task(T3, _, _).






At Start:


Is energy Max:
    Yes:
        Go to new oracle
        Do line 16
    No:
        Check if you can go to oracle and then back to station
            Yes:
                Go to oracle 
                Repeat line 16
            No: 
                Go to station
                Repeat line 11















    (Task = oracle -> % Either at the start, once just go to station, or at oracle and has enough energy left
        findall(
            [TotalCost, 0, [OracleLocation], Energy],
            (
            member(OracleLocation, OracleLocations),
            man_dist(0, OracleLocation, Pos, TotalCost) 
            ),
            Queue
        ),
        sort(Queue, NewQueue),
        T = go(Pos),
        solve_task_aStar(T ,NewQueue, [], Agent, Path),

        Path = [Location|Rest], % Location is where the oracle actually is
        Rest = [Adjacent|_],
        map_adjacent(Adjacent, Location, Obj), % Gets which oracle were next too

        reverse(Rest, [_|RevPath]), % Removing first element as thats where the agent is
        print_debug("RevPath", RevPath),
        agent_do_moves(Agent, RevPath), % Move to the oracles
        agent_ask_oracle(Agent,Obj,link,L), % Ask question
        include(actor_has_link(L),As,ViableAs), % Remove any actors that no longer fit
        select(Location, OracleLocations, NewOracleLocations), % Remove the oracle we just visited from teh list so it cant be visited again
        eliminate(ViableAs,A, Stations, NewOracleLocations, Task), % Call function again 
        true
    ;
        false    
    ).